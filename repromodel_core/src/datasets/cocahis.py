import os
import h5py
import requests
import numpy as np
from torch.utils.data import Dataset
from sklearn.model_selection import KFold, train_test_split
from repromodel_core.src.decorators import enforce_types_and_ranges, tag
from typing import Any, Tuple, Callable
from tqdm import tqdm
from albumentations.pytorch import ToTensorV2
import albumentations as A
from PIL import Image

@tag(task=["segmentation"], subtask=["binary"], modality=["medical"], submodality=["pathology"])
class CoCaHis(Dataset):
    @enforce_types_and_ranges({
        'hdf5_file_path': {'type': str},
        'in_channel': {'type': int, 'range': (1, 1000), 'default': 3},
        'mode': {'type': str, 'options': ['train', 'test'], 'default': 'train'},
        'transforms': {'type': Callable, 'default': None},  # Accepting function type
    })
    def __init__(self, hdf5_file_path: str, in_channel: int = 3, 
                 mode: str = 'train', transforms=None):
        self.hdf5_file_path = hdf5_file_path
        self.in_channel = in_channel
        self.mode = mode
        self.transforms = transforms

        # Check if the HDF5 file exists, if not, download it
        if not os.path.exists(self.hdf5_file_path):
            print(f"File not found at {self.hdf5_file_path}. Downloading now...")
            self.download_file()

        # Open the HDF5 file and load the raw data and GT_majority_vote
        with h5py.File(self.hdf5_file_path, 'r') as f:
            self.raw_data = f["HE/raw"][()]
            self.ground_truth = f["GT/GT_majority_vote"][()]
            self.patients = f["HE/"].attrs["patient_num"]
            self.split_info = f["HE/"].attrs["train_test_split"]
        
        # Extract train and test indices
        self.train_indices = np.where(self.split_info == 'train')[0]
        self.test_indices = np.where(self.split_info == 'test')[0]
        
        # Initialize validation indices and current fold index
        self.val_indices = None
        self.current_fold = None
        
        # Initialize storage for indices generated by k-fold
        self.indices = None

        # Generate train/val/test split if indices are not generated
        if mode != 'test':
            self.generate_indices()

        # Ensure that the mode is properly set
        self.set_mode(self.mode)

    def download_file(self):
        """Downloads the HDF5 file with progress tracking."""
        url = "http://cocahis.irb.hr/wp-content/uploads/2020/12/CoCaHis.hdf5"
        response = requests.get(url, stream=True)
        total_size = int(response.headers.get('content-length', 0))
        block_size = 1024  # 1 Kibibyte

        with open(self.hdf5_file_path, 'wb') as file, tqdm(
            desc=self.hdf5_file_path,
            total=total_size,
            unit='iB',
            unit_scale=True,
            unit_divisor=1024,
        ) as bar:
            for data in response.iter_content(block_size):
                file.write(data)
                bar.update(len(data))

    def generate_indices(self, k: int = 5, test_size: float = 0.2, random_seed: int = 42):
        """Generates k-fold indices for training and validation based on 'train' indices from train_test_split."""
        # Ensure train_indices is a numpy array for proper indexing
        self.train_indices = np.array(self.train_indices)

        # Generate k-fold indices for training and validation based on 'train' indices from train_test_split
        kf = KFold(n_splits=k, shuffle=True, random_state=random_seed)
        self.indices = []
        all_train_indices = np.arange(len(self.train_indices))
        for train_val_idx, _ in kf.split(all_train_indices):
            train_idx, val_idx = train_test_split(
                train_val_idx, test_size=test_size, random_state=random_seed
            )
            self.indices.append({
                'train': self.train_indices[train_idx].tolist(),
                'val': self.train_indices[val_idx].tolist(),
            })

        # Set the first fold by default
        self.set_fold(0)

    def set_mode(self, mode: str):
        if mode not in ['train', 'val', 'test']:
            raise ValueError("Mode should be 'train', 'val', or 'test'")
        self.mode = mode

    def set_transforms(self, transform):
        self.transforms = transform

    def set_fold(self, fold: int):
        if self.indices is None:
            raise RuntimeError("Please generate indices first using generate_indices()")
        if fold >= len(self.indices):
            raise ValueError("Fold index out of range")
        self.current_fold = fold
        self.train_indices = self.indices[fold]['train']
        self.val_indices = self.indices[fold]['val']

    def __len__(self) -> int:
        if self.mode == 'train':
            return len(self.train_indices)
        elif self.mode == 'val':
            return len(self.val_indices)
        elif self.mode == 'test':
            return len(self.test_indices)
        return 0

    def __getitem__(self, index: int) -> Tuple[Any, Any]:
        if self.mode == 'train':
            index = self.train_indices[index]
        elif self.mode == 'val':
            index = self.val_indices[index]
        elif self.mode == 'test':
            index = self.test_indices[index]

        # Load image and target
        img = self.raw_data[index]
        target = self.ground_truth[index]
        
        # Apply transformations if any
        if self.transforms is not None:
            img_np = np.array(img)
            target_np = np.array(target)
            transformed = self.transforms(image=img_np, mask=target_np)
            img = transformed['image']
            target = transformed['mask']

        # Convert target to binary label (no one-hot encoding for binary classification)
        target = np.array(target).astype(np.uint8)

        return img, target


if __name__ == "__main__":

    # Define the path where the HDF5 file should be located (or downloaded)
    hdf5_file_path = "repromodel_core/data/cocahis/CoCaHis.hdf5" 

    # Albumentations transforms
    transforms = A.Compose(
        [
            A.RandomCrop(height=512, width=512),
            A.HorizontalFlip(p=0.5),
            A.VerticalFlip(p=0.5),
            ToTensorV2()
        ]
    )

    # Initialize the dataset
    dataset = CoCaHis(
        hdf5_file_path=hdf5_file_path,
        in_channel=3,
        mode='train',
        transforms=transforms
    )

    # Check the length of the dataset (should return the number of train samples)
    print(f"Number of training samples: {len(dataset)}")

    # Get the first sample from the dataset
    img, label = dataset[0]
    print(f"Image size: {img.shape}, Label: {label.shape}")

    # Switch to validation mode and check length again
    dataset.set_mode('val')
    print(f"Number of validation samples: {len(dataset)}")

    # Get the first sample from the validation set
    img, label = dataset[0]
    print(f"Image size: {img.shape}, Label: {label.shape}")

    # Switch to test mode and check length again
    dataset.set_mode('test')
    print(f"Number of test samples: {len(dataset)}")

    # Get the first sample from the test set
    img, label = dataset[0]
    print(f"Image size: {img.shape}, Label: {label.shape}")

    # If you need to generate new indices and set to a specific fold
    dataset.generate_indices(k=5)  # Generate 5-fold indices
    dataset.set_fold(1)  # Switch to the second fold (index 1)

    # Visualize a single image using PIL show
    img, label = dataset[0]
    img = img.permute(1, 2, 0).numpy()  # Convert tensor to numpy array
    img = Image.fromarray(img)
    label = Image.fromarray(label.astype(np.uint8) * 255)
    img.show()
    label.show()

    # Check the length of the dataset in the current fold
    print(f"Number of training samples in fold 1: {len(dataset)}")